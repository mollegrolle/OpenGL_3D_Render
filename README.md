# OpenGL_3D_Render

This is my OpenGL 3D viewer project from the course "3D Programming" at BTH. In this project I implemented an interactive 3D application with specific rendering technqiues and GLSL shaders. It is possible to download this project, build and run to test it out.



## Deferred Rendering
I generate a framebuffer (g-buffer), five textures buffers and a depth buffer to store geometry data for a later pass. Before all geometry are rendered with my first Shaders (GeoPass), I bind the g-buffer with glBindFrameBuffer() so that geometry data can be sent to my texture buffers. After the scene is rendered and texture buffers are filled I unbind the g-buffer. Now when the buffers are filled I bind all 5 texture buffers to be rendered onto a quad that’s in front of the camera (ScreenQuad) to display the scene using the second shader (DefPass). Lightning calculations are done with the texture buffer data and the scene is displayed onto the ScreenQuad.
## Parsing OBJ
loadOBJ() function takes in a file path string and five empty vector arrays. The function opens the file path of the .obj file and loop through every line in the file in a while() loop. Every line goes through multiple if statements checking the first word on that line. If a line starts with ”v”, the text after the ”v” will be stored as vertex position data in a temp array. This will be done for every “v” known as position, every “vn” known as normal and every vt known as UV. Afterwards the line will come to “f” which tells us about the vertex data order, this is also stored. When no more lines are detected in the file, the loop breaks, and a second loop starts to fill the empty vector arrays with position, normal and UV data in the right order as well as tanget and bitanget data that are calculated in this second loop.
## Level-of-Detail using Tessellation
I configure the tessellation control shader and tessellation evaluation and set the glPatchParameteri() to three for triangulated patches. In the Control Shader I set the control points of the outputing patch and I check if the mesh should be tessellated with a bool. If the bool is set to true, then mesh will be tessellated based on the distance between camera and the three control points.
## Tessellation with displacement mapping
In the Evaluation Shader, a height map is used to translate the new vertices along their z normal. The height map is multiplied with the vertices normal together with a displacement factor that can be set by the user in the main loop.
## Normal Mapping
Normal maps are loaded through the Model loader class which reads the .mtl file when an obj file is loaded. The class imports the normal map texture, and if no normal map texture exists it creates a 1x1 pixel default normal map. The class also calculates tangent and bitangent. The tangent, bitangent and normal are multiplied with the model matrix and then formed to a TBN matrix. In the first render pass the normal map is sent into the fragment shader and multipled with the TBN matrix. The normal map stores its new data in a g-buffer that is then used in the second render pass, where the normal map is used to calculate light on the surface.
## Shadow mapping
A framebuffer is generated and prepared to store depth map texture from the directional light position. The resolution of the depth map is set in the glTexImage2D() to 8024 x 8024 pixels. In the loop I bind the framebuffer and render the geometry in the scene in light space to store the depth map from the light position. It is then sent to the first render pass (g-pass) where I calculate the distance to a pixel in the directional lights space coordinate and I compare it with the shadow maps depth value. If the distance to the pixel is greater than the depth in the shadow map I assume the pixel should be shadowed. I smooth the edge of the shadow by adding together the surrounding texels and returning the average value. The returned value is then multiplied with the lights.
## Back-face culling in geometry shader
In the geometry shader a normal is calculated by taking the cross product of two parallel vectors of the triangle plane. Taking the dot product of the normal with the view direction to get the angle value. If the value is 0 or more the triangle is culled.
